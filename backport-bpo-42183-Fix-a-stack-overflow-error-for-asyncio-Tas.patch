From 42d873c63aa9d160c132be4a34599531574db12c Mon Sep 17 00:00:00 2001
From: Andrew Svetlov <andrew.svetlov@gmail.com>
Date: Tue, 10 Nov 2020 15:58:31 +0200
Subject: [PATCH] bpo-42183: Fix a stack overflow error for asyncio Task or
 Future repr() (GH-23020)

The overflow occurs under some circumstances when a task or future
recursively returns itself.

Co-authored-by: Kyle Stanley <aeros167@gmail.com>
---
 Lib/asyncio/base_futures.py                        | 25 +++++++++++++++++++---
 Lib/test/test_asyncio/test_futures2.py             | 18 ++++++++++++++++
 .../2020-10-29-11-17-35.bpo-42183.50ZcIi.rst       |  4 ++++
 3 files changed, 44 insertions(+), 3 deletions(-)
 create mode 100644 Lib/test/test_asyncio/test_futures2.py
 create mode 100644 Misc/NEWS.d/next/Library/2020-10-29-11-17-35.bpo-42183.50ZcIi.rst

diff --git a/Lib/asyncio/base_futures.py b/Lib/asyncio/base_futures.py
index 5182884..2646fde 100644
--- a/Lib/asyncio/base_futures.py
+++ b/Lib/asyncio/base_futures.py
@@ -2,6 +2,7 @@ __all__ = ()
 
 import concurrent.futures._base
 import reprlib
+from _thread import get_ident
 
 from . import format_helpers
 
@@ -51,6 +52,16 @@ def _format_callbacks(cb):
     return f'cb=[{cb}]'
 
 
+# bpo-42183: _repr_running is needed for repr protection
+# when a Future or Task result contains itself directly or indirectly.
+# The logic is borrowed from @reprlib.recursive_repr decorator.
+# Unfortunately, the direct decorator usage is impossible because of
+# AttributeError: '_asyncio.Task' object has no attribute '__module__' error.
+#
+# After fixing this thing we can return to the decorator based approach.
+_repr_running = set()
+
+
 def _future_repr_info(future):
     # (Future) -> str
     """helper function for Future.__repr__"""
@@ -59,9 +70,17 @@ def _future_repr_info(future):
         if future._exception is not None:
             info.append(f'exception={future._exception!r}')
         else:
-            # use reprlib to limit the length of the output, especially
-            # for very long strings
-            result = reprlib.repr(future._result)
+            key = id(future), get_ident()
+            if key in _repr_running:
+                result = '...'
+            else:
+                _repr_running.add(key)
+                try:
+                    # use reprlib to limit the length of the output, especially
+                    # for very long strings
+                    result = reprlib.repr(future._result)
+                finally:
+                    _repr_running.discard(key)
             info.append(f'result={result}')
     if future._callbacks:
         info.append(_format_callbacks(future._callbacks))
diff --git a/Lib/test/test_asyncio/test_futures2.py b/Lib/test/test_asyncio/test_futures2.py
new file mode 100644
index 0000000..c78b0cb
--- /dev/null
+++ b/Lib/test/test_asyncio/test_futures2.py
@@ -0,0 +1,18 @@
+# IsolatedAsyncioTestCase based tests
+import asyncio
+import unittest
+
+
+class FutureTests(unittest.TestCase):
+    async def test_recursive_repr_for_pending_tasks(self):
+        # The call crashes if the guard for recursive call
+        # in base_futures:_future_repr_info is absent
+        # See Also: https://bugs.python.org/issue42183
+
+        async def func():
+            return asyncio.all_tasks()
+
+        # The repr() call should not raise RecursiveError at first.
+        # The check for returned string is not very reliable but
+        # exact comparison for the whole string is even weaker.
+        self.assertIn('...', repr(await asyncio.wait_for(func(), timeout=10)))
diff --git a/Misc/NEWS.d/next/Library/2020-10-29-11-17-35.bpo-42183.50ZcIi.rst b/Misc/NEWS.d/next/Library/2020-10-29-11-17-35.bpo-42183.50ZcIi.rst
new file mode 100644
index 0000000..f6d7653
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2020-10-29-11-17-35.bpo-42183.50ZcIi.rst
@@ -0,0 +1,4 @@
+Fix a stack overflow error for asyncio Task or Future repr().
+
+The overflow occurs under some circumstances when a Task or Future
+recursively returns itself.
-- 
1.8.3.1

