From d3dcc92778807ae8f7ebe85178f36a29711cd478 Mon Sep 17 00:00:00 2001
From: Victor Stinner <vstinner@redhat.com>
Date: Mon, 19 Aug 2019 23:37:17 +0100
Subject: [PATCH] bpo-37788: Fix a reference leak if a thread is not joined
 (GH-15228)

Add threading.Thread.__del__() method to ensure that the thread state
lock is removed from the _shutdown_locks list when a thread
completes.
---
 Lib/test/test_threading.py                             |  8 ++++++++
 Lib/threading.py                                       | 10 ++++++++++
 .../Library/2019-08-12-17-21-10.bpo-37788.F0tR05.rst   |  1 +
 3 files changed, 19 insertions(+)
 create mode 100644 Misc/NEWS.d/next/Library/2019-08-12-17-21-10.bpo-37788.F0tR05.rst

diff --git a/Lib/test/test_threading.py b/Lib/test/test_threading.py
index 7c16974c1630a..5e90627822f9f 100644
--- a/Lib/test/test_threading.py
+++ b/Lib/test/test_threading.py
@@ -761,6 +761,14 @@ def test_shutdown_locks(self):
                 # Daemon threads must never add it to _shutdown_locks.
                 self.assertNotIn(tstate_lock, threading._shutdown_locks)
 
+    def test_leak_without_join(self):
+        # bpo-37788: Test that a thread which is not joined explicitly
+        # does not leak. Test written for reference leak checks.
+        def noop(): pass
+        with support.wait_threads_exit():
+            threading.Thread(target=noop).start()
+            # Thread.join() is not called
+
 
 class ThreadJoinOnShutdown(BaseTestCase):
 
diff --git a/Lib/threading.py b/Lib/threading.py
index 32a3d7c303362..67e1c4facfee2 100644
--- a/Lib/threading.py
+++ b/Lib/threading.py
@@ -806,6 +806,16 @@ class is implemented.
         # For debugging and _after_fork()
         _dangling.add(self)
 
+    def __del__(self):
+        if not self._initialized:
+            return
+        lock = self._tstate_lock
+        if lock is not None and not self.daemon:
+            # ensure that self._tstate_lock is not in _shutdown_locks
+            # if join() was not called explicitly
+            with _shutdown_locks_lock:
+                _shutdown_locks.discard(lock)
+
     def _reset_internal_locks(self, is_alive):
         # private!  Called by _after_fork() to reset our internal locks as
         # they may be in an invalid state leading to a deadlock or crash.
diff --git a/Misc/NEWS.d/next/Library/2019-08-12-17-21-10.bpo-37788.F0tR05.rst b/Misc/NEWS.d/next/Library/2019-08-12-17-21-10.bpo-37788.F0tR05.rst
new file mode 100644
index 0000000000000..d9b1e82b92238
--- /dev/null
+++ b/Misc/NEWS.d/next/Library/2019-08-12-17-21-10.bpo-37788.F0tR05.rst
@@ -0,0 +1 @@
+Fix a reference leak if a thread is not joined.
